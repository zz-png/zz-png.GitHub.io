---
title: 图解密码技术笔记
date:  2021-01-09 18:22:39
category: theory
tags: cryptograph
excerpt: 《图解密码技术》相关知识总结
---

### 一.密码技术

|信息安全所面临的威胁|受威胁的特性|用来应对的密码技术|
|:---:|:---:|:---:|
|窃听（秘密泄露）|机密性|对称密码，公钥密码|
|篡改（信息被修改）|完整性|单向散列函数|
|伪装（伪装成发送者）|认证|消息认证码|
|否认（事后称自己没有做）|不可否认性|数字签名|

消息认证码还可以保证完整性，数字签名还可以检测出篡改和伪装

### 二.历史上的密码

介绍了凯撒密码，简单替换密码，Enigma密码机

### 三.对称密码

+ 一次性密码本：无法破译，但是存在密钥配送、保存、重用、同步和生成等问题
+ DES(Data Encryption Standard):将64比特的明文加密成64比特的密文的对称密码算法，已经可以在短时间内破译
+ 三重DES：为了增强DES的强度，将DES重复3次所得到的一种密码算法，通常缩写为3DES，可以向下兼容DES<br>
加密过程为：使用密钥1，密钥2，密钥3进行加密，解密，加密操作<br>
解密过程为：以密钥3，密钥2，密钥1的顺序执行解密，加密，解密的操作
+ AES(Advanced Encryption Standard)算法：有5个算法入围AES最终候选算法名单，最后确定为Rijndael

### 四.分组密码的模式
DES和AES都属于分组密码，分组密码算法只能加密固定长度的分组，但是需要加密的明文长度可能会超过分组密码的分组长度，这时就需要对分组密码算法进行迭代，以便将一段很长的明文全部加密。而迭代的方法就称为分组密码的模式。主要模式有5种：ECB,CBC,CFB,OFB和CTR
<br>分组密码算法的选择固然很重要，但模式的选择也很重要。同样一个分组密码算法，根据用途的不同可以以多种模式来工作。对模式完全不了解的用户在使用分组密码时，最常见的做法就是将明文分组按顺序分别加密，而这样做的结果就相当于使用了安全性最差的ECB模式

### 五.公钥密码
在对称密码中，由于加密和解密的密钥是相同的，因此必须向接收者配送密钥。解决密钥配送问题的方法有：

1. 通过实现共享密钥来解决
2. 通过密钥分配中心来解决
3. 通过Diffie-Hellman密钥交换来解决
4. 通过公钥密码来解决

公钥密码的通信流程，Alice是发送者，Bob是接收者，通信过程是由接收者Bob来启动的

1. Bob生成一个包含公钥和私钥的密钥对。私钥由Bob自行妥善保管
2. Bob将自己的公钥发送给Alice,请Alice用这个公钥对消息进行加密并发送给他，公钥即使被截获也没关系
3. Alice用Bob的公钥对消息进行加密并将密文发送给Bob
4. Bob用自己的私钥对密文进行解密

RSA公钥密码算法：密文 = 明文 ^ E mod N,明文 = 密文 ^ D mod N
<br>E和N的组合就是公钥，D和N的组合就是私钥(N是公钥的一部分，单独称D为私钥也行)
<br>其他公钥密码：ElGamal方式，Rabin方式以及椭圆曲线密码
<br>仅依靠公钥密码本身，无法防御中间人攻击

### 六.单向散列函数
单向散列函数可以保证数据的完整性，需要具备以下性质：

+ 根据任意长度的消息计算出固定长度的散列值
+ 能够快速计算出散列值
+ 消息不同散列值也不同，具有抗碰撞性
   +  弱抗碰撞性：要找到和该条消息具有相同散列值的另外一条消息是非常困难的
   +  强抗碰撞性：要找到散列值相同的两条不同的消息是非常困难的
+ 具备单向性，无法通过散列值反算出消息的性质

几种单向散列函数：

1. MD4、MD5：能够产生128比特的散列值，但是已经不安全了
2. SHA-1、SHA-256、SHA-384、SHA-512：散列值分别为160比特，256比特，384比特和512比特（SHA-1的强抗碰撞性已被攻破）
3. RIPEMD-160：能够产生160比特的散列值（RIPEMD的强抗碰撞性已被攻破，但RIPEMD-160还没有）
4. AHS(Advanced Hash Standard)和SHA-3

对单向散列函数的攻击方式有暴力破解（破解弱抗碰撞性）和生日攻击（破解强抗碰撞性）
<br>单向散列函数能够辨别出“篡改”，但是无法辨别“伪装”，当我们需要确认文件是否真的属于Alice时，还需要进行认证
<br>用于认证的技术包括消息认证码和数字签名

+ 消息认证码：能够向通信对象保证消息没有被篡改和伪装
+ 数字签名：不仅能够向通信对象保证，还能向所有第三方做出这样的保证

### 七.消息认证码
消息认证码（message authentication code）是一种确认完整性并进行认证的技术，可以理解为一种与密钥相关联的单向散列函数
<br>消息认证码的使用步骤为：

1. 发送者Alice与接收者Bob事先共享密钥
2. Alice根据汇款请求消息计算MAC值（使用共享密钥）
3. Alice将汇款请求消息和MAC值发送给Bob
4. Bob根据接收到的汇款请求消息计算MAC值（使用共享密钥）
5. Bob将自己计算的MAC值与从Alice处收到的MAC值进行对比
6. 如果两个MAC一致，则Bob可以断定汇款请求来自Alice(认证成功)，否则消息不是来自Alice(认证失败)

对消息认证码的攻击：

1. 重放攻击，防御重放攻击的方法有：序号，时间戳和nonce（一个一次性的随机数）
2. 密钥推测攻击，和对单向散列函数的攻击一样，对消息认证码也可以进行暴力破解

消息认证码无法解决“对第三方证明”和“防止否认”的问题

### 八.数字签名
使用数字签名可以识别篡改和伪装，还可以防止否认
<br>数字签名中同样会使用公钥和私钥组成的密钥对，不过这两个密钥的用法和公钥密码是相反的，也就是用私钥加密相当于生成签名，而用公钥解密相当于验证签名
<br>直接对消息签名的方法比较简单，但是实际上并不会使用，一般都是对消息的散列值签名,具体步骤为：

1. Alice用单向散列函数计算消息的散列值
2. Alice用自己的私钥对散列值进行加密,所得到的密文其实就是对这条散列值的签名
3. Alice将消息和签名发送给Bob
4. Bob用Alice的公钥对收到的签名进行解密
5. Bob将签名解密后得到的散列值与Alice直接发送的消息的散列值进行对比,如果一致则签名验证成功

从上述过程来看，消息没有经过加密就发送了，这样不久无法保证消息的机密性了吗？
<br>**的确如此，但是数字签名的作用本来就不是保证机密性。此外，数字签名要实现的并不是防止修改，而是识别修改**

对数字签名的攻击：

1. 中间人攻击
2. 对单向散列函数的攻击
3. 利用数字签名攻击公钥密码
4. 其他攻击（暴力破解等）

然而，要正确使用数字签名，有一个大前提，那就是用于验证签名的公钥必须属于真正的发送者
<br>这样一来，我们发现自己陷入了一个死循环——数字签名是用来识别消息篡改、伪装以及否认的，但是为此我们又必须从没有被伪装的发送者得到没有被篡改的公钥才行
<br>为了能够确认自己得到的公钥是否合法，我们需要使用证书。所谓证书，就是将公钥当作一条消息，由一个可信的第三方对其签名后所得到的公钥

### 九.证书
公钥证书其实和驾照很相似，里面记有姓名、组织、邮箱地址等个人信息，以及属于此人的公钥，并由认证机构施加数字签名
<br>Alice利用认证机构Trent向Bob发送密文的事例：

1. Bob生成密钥对（在这里，密钥对是由Bob自己生成的，也可以由认证机构代为生成）
2. Bob在认证机构Trent注册自己的公钥，Trent收到Bob的公钥后会确认是否为Bob本人所有
3. 认证机构Trent用自己的私钥对Bob的公钥施加数字签名并生成证书
4. Alice从Trent处获取带有其数字签名的Bob的公钥（证书）
5. Alice使用认证机构Trent的公钥验证数字签名，确认Bob的公钥的合法性
6. Alice用Bob的公钥加密消息并发送给Bob
7. Bob用自己的私钥解密密文得到Alice的消息

公钥基础设施（PKI）是为了能够有效运用公钥而制定的一系列规范和规格的总称，组成要素有以下3个：

+ 用户——使用PKI的人
+ 认证机构（CA）——颁发证书的人
+ 仓库——保存证书的数据库

对证书的攻击方式：

1. 在公钥注册之前进行攻击，攻击者将公钥替换成自己的
2. 注册相似人名进行攻击
3. 窃取认证机构的私钥进行攻击
4. 攻击者伪装成认证机构进行攻击
5. 利用CRL（证书作废清单）发布的时间差进行攻击
6. 通过钻CRL的空子实现否认

### 十.随机数
在这里随机数的性质分为三类：

+ 随机性——不存在统计学偏差，是完全杂乱的数列
+ 不可预测性——不能从过去的数列推测出下一个出现的数
+ 不可重现性——除非将数列本身保存下来，否则不能重现相同的数列

具备不可预测性的随机数，一定具备随机性。具备不可重现性的随机数，也一定具备随机性和不可预测性
<br>将分别具有以上性质的随机数称为弱伪随机数，强伪随机数，真随机数
<br>随机数可以通过硬件来生成，也可以通过软件来生成

+ 要生成具有不可重现性的随机数列，需要从不可重现的物理现象中获取信息，比如周围的温度和声音的变化，用户移动的鼠标的位置信息，放射性测量仪的输出值等，根据从这些硬件中获取的事实上无法预测和重现的自然现象信息来生成的数列，一般可以认为是真随机数
+ 仅靠软件无法生成真随机数，这种软件称为伪随机数生成器

对伪随机数生成器的攻击：

1. 对种子进行攻击
2. 对随机数池进行攻击